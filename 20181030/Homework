1. 写一个函数，函数声明如下：

void triangle_judge(int a, int b, int c);

该函数接受三个整数值，判断其是否可以构成三角形。若可以，请输出三角形类型，包括：普通三角形、等腰三角形、等边三角形。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为1.c）。


2. 写一个函数，函数声明如下：

void print_hex(int a);

该函数接受一个十进制整数值，打印出其十六进制表示。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：不要直接使用printf的格式控制符来操作；程序命名为2.c）。


3. 写一个函数，函数声明如下：

int is_pow2(int n);

该函数接受一个整数，若该数为2的幂次方（1,2,4,8..），返回 0；否则，返回-1。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：使用位运算；程序命名为3.c）。


4. 写一个函数，函数声明如下：

int count1_in_bin(int n);

该函数接受一个整数，返回该数的二进制表示中1的个数。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：可使用位运算；程序命名为4.c）。


5. 写一个函数，函数声明如下：

int fac_bit_count(int n);

该函数接受任意（int型）整数n，返回n!的位数。如，若n为10，则10!=3628800，共7位，该函数返回7。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：32位的int型数据可表示的最大整数为2^31 – 1 = 2147483647，因此当n略大时，n!会超过int所能表示的范围；程序命名为5.c）。


6. 写一个函数，函数声明如下：

int is_prime(int n);

该函数接受任意（int型）整数n，判断n是否为素数。若是，返回0；否则，返回-1。在主函数中使用该函数，打印出第100至第1000个素数（第一个素数为2）（注：程序命名为6.c）。


7. 使用欧几里得辗转相除法求两个正整数最大公约数，请分别给出循环实现与递归实现。函数声明如下：

int GCD_recursive(int m, int n);
int GCD_iterative(int m, int n);

GCD_recursive为递归版本；GCD_iterative为循环（迭代）版本。在主函数中分别使用这两个函数，并进行多组测试，以验证你的函数（注：程序命名为7.c）。


8. 基于最大公约数的实现，求两个正整数的最小公倍数。函数声明如下：

int LCM(int m, int n);

在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为8.c）。


9. 写一个函数，函数声明如下：

int is_int_pal(int n);

该函数接受一个整数，若该数为回文数（如12321），返回 0；否则，返回-1。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为9.c）。


10. 写一个函数，函数声明如下：

int is_str_pal(const char* str);

该函数接受一个字符串，若该字符串为回文串（如"12321"），返回 0；否则，返回-1。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为10.c）。


11. 写一个函数，函数声明如下：

void reverse(char* str);

该函数接受一个字符串， 将此串反转（如："Homework"的反转为"krowemoH"）在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为11.c）。


12. 写一个函数，函数声明如下：

void matrix_product(int mat1[][K], int mat2[][N], int product[][N]);

该函数接受三个参数，分别是三个二维数组。其中，mat1表示M×K的矩阵，mat2表示K×N的矩阵，product表示M×N的矩阵。M、N、K是预先定义的宏。例如：

#define M 4
#define K 5
#define N 6

该函数计算mat1与mat2的乘积，并将该乘积保存在product中。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为12.c）。


13. 写一个函数，函数声明如下：

void matrix_transpose (int mat[][N], int transposed[][M]);

该函数接受两个参数，分别是两个个二维数组。其中，mat表示M×N的矩阵，transposed表示N×M的矩阵。M、N是预先定义的宏。例如：

#define M 4
#define N 5

该函数将mat进行转置，并将转置的结果保存在transposed中。在主函数中调用该函数，并进行多组测试，以验证你的函数（注：程序命名为13.c）。


14. 阅读教材 P258 至 P263，了解宏的使用（注：此题不用写程序）。


15. 仔细阅读教材P130至P140，学会使用几个常用的字符串处理函数包括但不仅限于 gets, puts, strcat，strcpy, strcmp, strlen。这些函数往往不安全，你可以查阅网上的资料与博客，了解这些函数的缺陷，并在使用时避免踩坑（注：此题不用写程序）。


16. 查阅网上的资料与博客，了解调用栈(call stack)（注：此题不用写程序）。


注：
1）作业提交到自己仓库的19180xxx/20181030目录下，19180xxx为你的学号。
2）建议每做完一道题目后，使用git add*将其添加，但暂且不要用git commit将其提交。所有题目完成后，使用git commit提交，之后再git push。
3）慎用git commit。请确保无误后，再进行commit，以防造成文件混乱。
4）截止日期：2018.11.6-00:00:00（零点）。
